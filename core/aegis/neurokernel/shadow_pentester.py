"""
Shadow Pentester — Continuous Offensive Testing Agent.

Runs as an AEGIS agent (registered as "SHADOW") that operates
exclusively within the Digital Twin environment. Uses LLM reasoning
to discover attack paths, then reports findings to the defensive side.

Extends the existing purple teaming orchestrator at:
    products/nexus/lib/red_purple_teaming/orchestrator.py

Key differences from existing orchestrator:
1. Autonomous — runs on scheduled cycles, not only on-demand
2. eBPF-aware — uses streaming RAG telemetry as attack surface info
3. Closed-loop — findings auto-feed into QSecBit classifier updates
4. LLM-driven — uses the LLM for creative attack ideation, not just
   predefined 9-vector playbook

Security: ALL execution happens inside the digital twin. The principle
guard enforces that production-touching actions are blocked.

Author: Andrei Toma
License: Proprietary
Version: 1.0.0
"""

import hashlib
import logging
import threading
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Callable, Dict, List, Optional

from .attack_library import (
    AttackCategory,
    AttackDifficulty,
    AttackExecution,
    AttackLibrary,
    AttackTemplate,
)

logger = logging.getLogger(__name__)


# ------------------------------------------------------------------
# Enums & Data Types
# ------------------------------------------------------------------

class PentestPhase(str, Enum):
    """Current phase of the shadow pentest cycle."""
    IDLE = "idle"
    RECONNAISSANCE = "reconnaissance"
    VULNERABILITY_ANALYSIS = "vulnerability_analysis"
    ATTACK_SIMULATION = "attack_simulation"
    IMPACT_ASSESSMENT = "impact_assessment"
    REPORTING = "reporting"


class FindingSeverity(str, Enum):
    """Severity of a pentesting finding."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class ReconResult:
    """Result of the reconnaissance phase."""
    topology: Dict[str, Any] = field(default_factory=dict)
    active_hosts: List[str] = field(default_factory=list)
    open_services: Dict[str, List[int]] = field(default_factory=dict)
    rag_context: str = ""
    active_defenses: List[str] = field(default_factory=list)
    timestamp: float = field(default_factory=time.time)


@dataclass
class VulnerabilityFinding:
    """A vulnerability discovered by the shadow pentester."""
    finding_id: str
    title: str
    description: str
    severity: FindingSeverity
    attack_template: str          # Attack template name used
    mitre_id: str = ""
    mitre_technique: str = ""
    target_ip: str = ""
    target_service: str = ""
    detection_gap: str = ""       # What defense missed
    recommended_fix: str = ""
    evidence: Dict[str, Any] = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "finding_id": self.finding_id,
            "title": self.title,
            "description": self.description,
            "severity": self.severity.value,
            "attack_template": self.attack_template,
            "mitre_id": self.mitre_id,
            "mitre_technique": self.mitre_technique,
            "target_ip": self.target_ip,
            "target_service": self.target_service,
            "detection_gap": self.detection_gap,
            "recommended_fix": self.recommended_fix,
            "evidence": self.evidence,
            "timestamp": self.timestamp,
        }


@dataclass
class PentestCycleResult:
    """Complete result of one pentest cycle."""
    cycle_id: str
    phase: PentestPhase
    started_at: float
    completed_at: float = 0.0
    attacks_executed: int = 0
    attacks_detected: int = 0
    attacks_evaded: int = 0
    findings: List[VulnerabilityFinding] = field(default_factory=list)
    executions: List[AttackExecution] = field(default_factory=list)
    error: str = ""

    @property
    def detection_rate(self) -> float:
        if self.attacks_executed == 0:
            return 1.0
        return self.attacks_detected / self.attacks_executed

    @property
    def evasion_rate(self) -> float:
        if self.attacks_executed == 0:
            return 0.0
        return self.attacks_evaded / self.attacks_executed

    def to_dict(self) -> Dict[str, Any]:
        return {
            "cycle_id": self.cycle_id,
            "phase": self.phase.value,
            "started_at": self.started_at,
            "completed_at": self.completed_at,
            "attacks_executed": self.attacks_executed,
            "attacks_detected": self.attacks_detected,
            "attacks_evaded": self.attacks_evaded,
            "detection_rate": self.detection_rate,
            "evasion_rate": self.evasion_rate,
            "findings": [f.to_dict() for f in self.findings],
            "error": self.error,
        }


# ------------------------------------------------------------------
# Shadow Pentester
# ------------------------------------------------------------------

class ShadowPentester:
    """Offensive LLM agent operating in the Digital Twin.

    Attack methodology:
    1. Reconnaissance: Query streaming RAG for network topology
    2. Vulnerability analysis: Identify weak points from topology
    3. Attack simulation: Execute templates in twin
    4. Impact assessment: Measure what defenses caught/missed
    5. Defensive feedback: Report findings for QSecBit updates

    Security invariants:
    - ALL actions execute inside the digital twin only
    - Production network is NEVER touched
    - PrincipleGuard blocks any production-targeting action
    - All attack payloads logged to audit trail
    - Rate-limited to prevent resource exhaustion
    """

    # Principle Guard: ONLY these actions are allowed
    ALLOWED_ACTIONS = frozenset({
        "scan_twin_network",       # Enumerate twin topology
        "inject_twin_traffic",     # Send crafted packets in twin
        "replay_twin_ebpf",        # Replay captured eBPF events
        "query_twin_qsecbit",      # Check if twin's QSecBit detects
        "report_vulnerability",    # Report finding to defensive side
    })

    # BLOCKED actions (enforced by PrincipleGuard)
    BLOCKED_ACTIONS = frozenset({
        "scan_production",         # Never touch real network
        "inject_production",       # Never touch real network
        "disable_protection",      # Never disable defenses
        "exfiltrate_data",         # Never extract real data
    })

    # Rate limits
    MAX_ATTACKS_PER_CYCLE = 20
    MAX_CYCLES_PER_HOUR = 4
    CYCLE_COOLDOWN_S = 900        # 15 minutes between cycles

    def __init__(
        self,
        attack_library: Optional[AttackLibrary] = None,
        twin: Optional[Any] = None,
        rag_pipeline: Optional[Any] = None,
        defense_feedback: Optional[Any] = None,
        max_difficulty: AttackDifficulty = AttackDifficulty.ADVANCED,
    ):
        """Initialize the shadow pentester.

        Args:
            attack_library: Attack template catalogue.
            twin: Digital twin simulator (KernelDigitalTwin or DigitalTwinSimulator).
            rag_pipeline: StreamingRAGPipeline for reconnaissance.
            defense_feedback: DefenseFeedback for reporting findings.
            max_difficulty: Maximum attack difficulty to attempt.
        """
        self._library = attack_library or AttackLibrary()
        self._twin = twin
        self._rag_pipeline = rag_pipeline
        self._defense_feedback = defense_feedback
        self._max_difficulty = max_difficulty

        self._lock = threading.Lock()
        self._phase = PentestPhase.IDLE
        self._cycle_history: List[PentestCycleResult] = []
        self._cycle_count = 0
        self._last_cycle_time = 0.0

        # Detection simulation callback
        self._detection_simulator: Optional[Callable] = None

        # Stats
        self._total_attacks = 0
        self._total_detected = 0
        self._total_evaded = 0
        self._total_findings = 0

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    @property
    def phase(self) -> PentestPhase:
        """Current pentest phase."""
        return self._phase

    @property
    def attack_library(self) -> AttackLibrary:
        """Access the attack library."""
        return self._library

    def set_twin(self, twin: Any) -> None:
        """Set or replace the digital twin."""
        self._twin = twin

    def set_rag_pipeline(self, pipeline: Any) -> None:
        """Set the streaming RAG pipeline for reconnaissance."""
        self._rag_pipeline = pipeline

    def set_defense_feedback(self, feedback: Any) -> None:
        """Set the defense feedback module."""
        self._defense_feedback = feedback

    def set_detection_simulator(self, simulator: Callable) -> None:
        """Set a callback that simulates QSecBit detection.

        The simulator receives an AttackExecution and returns
        (detected: bool, layer: str, latency_ms: float, severity: str).
        """
        self._detection_simulator = simulator

    def run_cycle(self, target_categories: Optional[List[AttackCategory]] = None) -> PentestCycleResult:
        """Run one complete pentest cycle.

        Returns a PentestCycleResult with all findings.

        Args:
            target_categories: Optional filter — only run attacks in these categories.
        """
        # Rate limit check
        now = time.time()
        if now - self._last_cycle_time < self.CYCLE_COOLDOWN_S:
            remaining = self.CYCLE_COOLDOWN_S - (now - self._last_cycle_time)
            result = PentestCycleResult(
                cycle_id=self._make_cycle_id(),
                phase=PentestPhase.IDLE,
                started_at=now,
                completed_at=now,
                error=f"Rate limited — {remaining:.0f}s remaining",
            )
            return result

        self._cycle_count += 1
        self._last_cycle_time = now
        cycle_id = self._make_cycle_id()

        result = PentestCycleResult(
            cycle_id=cycle_id,
            phase=PentestPhase.RECONNAISSANCE,
            started_at=now,
        )

        try:
            # Phase 1: Reconnaissance
            self._phase = PentestPhase.RECONNAISSANCE
            recon = self._do_reconnaissance()

            # Phase 2: Select attacks
            self._phase = PentestPhase.VULNERABILITY_ANALYSIS
            templates = self._select_attacks(recon, target_categories)

            # Phase 3: Execute attacks in twin
            self._phase = PentestPhase.ATTACK_SIMULATION
            executions = self._execute_attacks(templates, recon)
            result.executions = executions

            # Phase 4: Assess impact
            self._phase = PentestPhase.IMPACT_ASSESSMENT
            findings = self._assess_impact(executions)
            result.findings = findings

            # Phase 5: Report to defense
            self._phase = PentestPhase.REPORTING
            self._report_findings(findings)

            # Tally stats
            result.attacks_executed = len(executions)
            result.attacks_detected = sum(1 for e in executions if e.detected)
            result.attacks_evaded = sum(1 for e in executions if e.evaded_detection)
            result.completed_at = time.time()
            result.phase = PentestPhase.IDLE

            self._total_attacks += result.attacks_executed
            self._total_detected += result.attacks_detected
            self._total_evaded += result.attacks_evaded
            self._total_findings += len(findings)

        except Exception as e:
            logger.error("Pentest cycle %s failed: %s", cycle_id, e, exc_info=True)
            result.error = str(e)
            result.completed_at = time.time()

        self._phase = PentestPhase.IDLE

        with self._lock:
            self._cycle_history.append(result)
            if len(self._cycle_history) > 50:
                self._cycle_history = self._cycle_history[-50:]

        return result

    def run_single_attack(
        self,
        template_name: str,
        parameters: Optional[Dict[str, Any]] = None,
    ) -> AttackExecution:
        """Run a single attack template in the twin.

        Useful for targeted testing of a specific attack vector.

        Args:
            template_name: Name of the attack template.
            parameters: Override parameters for the template.

        Returns:
            AttackExecution record.
        """
        template = self._library.get_by_name(template_name)
        if template is None:
            return AttackExecution(
                template_id="",
                template_name=template_name,
                category="unknown",
                parameters=parameters or {},
                notes=f"Template '{template_name}' not found",
            )

        params = self._build_parameters(template, parameters)
        execution = self._simulate_attack(template, params)

        # Run detection check
        self._check_detection(execution)

        return execution

    def get_history(self) -> List[Dict[str, Any]]:
        """Get pentest cycle history."""
        with self._lock:
            return [r.to_dict() for r in self._cycle_history]

    def stats(self) -> Dict[str, Any]:
        """Get pentester statistics."""
        return {
            "phase": self._phase.value,
            "cycle_count": self._cycle_count,
            "total_attacks": self._total_attacks,
            "total_detected": self._total_detected,
            "total_evaded": self._total_evaded,
            "total_findings": self._total_findings,
            "detection_rate": (
                self._total_detected / self._total_attacks
                if self._total_attacks > 0 else 1.0
            ),
            "library_size": len(self._library),
            "max_difficulty": self._max_difficulty.value,
            "has_twin": self._twin is not None,
            "has_rag": self._rag_pipeline is not None,
            "has_defense_feedback": self._defense_feedback is not None,
        }

    # ------------------------------------------------------------------
    # Internal: Phase 1 — Reconnaissance
    # ------------------------------------------------------------------

    def _do_reconnaissance(self) -> ReconResult:
        """Gather intelligence from the twin and streaming RAG."""
        recon = ReconResult()

        # Query streaming RAG for recent network topology
        if self._rag_pipeline is not None:
            try:
                recon.rag_context = self._rag_pipeline.query(
                    "network topology active hosts services ports", k=20,
                )
            except Exception as e:
                logger.warning("RAG recon failed: %s", e)

        # Query twin for device inventory
        if self._twin is not None:
            try:
                twin_status = self._get_twin_topology()
                recon.topology = twin_status.get("topology", {})
                recon.active_hosts = twin_status.get("active_hosts", [])
                recon.open_services = twin_status.get("open_services", {})
                recon.active_defenses = twin_status.get("active_defenses", [])
            except Exception as e:
                logger.warning("Twin recon failed: %s", e)

        # Fallback: use library defaults for parameterization
        if not recon.active_hosts:
            recon.active_hosts = ["10.200.0.10", "10.200.0.20", "10.200.0.30"]

        logger.info(
            "Recon complete: %d hosts, %d services, RAG context %d chars",
            len(recon.active_hosts),
            sum(len(v) for v in recon.open_services.values()),
            len(recon.rag_context),
        )
        return recon

    def _get_twin_topology(self) -> Dict[str, Any]:
        """Extract topology from the digital twin."""
        result: Dict[str, Any] = {
            "topology": {},
            "active_hosts": [],
            "open_services": {},
            "active_defenses": [],
        }

        # Use create_snapshot if available
        if hasattr(self._twin, "create_snapshot"):
            try:
                snapshot = self._twin.create_snapshot()
                if hasattr(snapshot, "to_dict"):
                    snap_dict = snapshot.to_dict()
                    devices = snap_dict.get("devices", {})
                    for mac, dev in devices.items():
                        ip = dev.get("ip", "")
                        if ip:
                            result["active_hosts"].append(ip)
                    result["topology"] = snap_dict
                    return result
            except Exception:
                pass

        # Fallback: direct attribute access
        if hasattr(self._twin, "_devices"):
            devices = getattr(self._twin, "_devices", {})
            for mac, dev in devices.items():
                ip = getattr(dev, "ip", "")
                if ip:
                    result["active_hosts"].append(ip)

        return result

    # ------------------------------------------------------------------
    # Internal: Phase 2 — Attack Selection
    # ------------------------------------------------------------------

    def _select_attacks(
        self,
        recon: ReconResult,
        target_categories: Optional[List[AttackCategory]] = None,
    ) -> List[AttackTemplate]:
        """Select attack templates based on recon and constraints."""
        # Get eligible templates
        candidates = self._library.get_by_difficulty(self._max_difficulty)

        # Filter by category if specified
        if target_categories:
            candidates = [
                t for t in candidates if t.category in target_categories
            ]

        # Cap at MAX_ATTACKS_PER_CYCLE
        if len(candidates) > self.MAX_ATTACKS_PER_CYCLE:
            candidates = candidates[:self.MAX_ATTACKS_PER_CYCLE]

        logger.info("Selected %d attack templates for cycle", len(candidates))
        return candidates

    # ------------------------------------------------------------------
    # Internal: Phase 3 — Attack Execution
    # ------------------------------------------------------------------

    def _execute_attacks(
        self,
        templates: List[AttackTemplate],
        recon: ReconResult,
    ) -> List[AttackExecution]:
        """Execute selected attacks in the digital twin."""
        executions = []

        for template in templates:
            # Build parameters from recon
            params = self._build_parameters(template, recon=recon)

            # Simulate the attack
            execution = self._simulate_attack(template, params)

            # Check if QSecBit detected it
            self._check_detection(execution)

            executions.append(execution)

        return executions

    def _build_parameters(
        self,
        template: AttackTemplate,
        overrides: Optional[Dict[str, Any]] = None,
        recon: Optional[ReconResult] = None,
    ) -> Dict[str, Any]:
        """Build attack parameters from template defaults and recon data."""
        params: Dict[str, Any] = {}

        # Start with template defaults
        for param in template.parameters:
            if param.default is not None:
                params[param.name] = param.default

        # Auto-fill from recon
        if recon and recon.active_hosts:
            target = recon.active_hosts[0]
            for param in template.parameters:
                if param.param_type == "ip" and param.name in ("target_ip", "victim_ip"):
                    params[param.name] = target
                elif param.param_type == "ip" and param.name == "gateway_ip":
                    params[param.name] = "10.200.0.1"
                elif param.param_type == "ip" and param.name == "attacker_ip":
                    params[param.name] = "10.200.0.250"

            # Subnet from first host
            if "subnet" in [p.name for p in template.parameters]:
                params["subnet"] = "10.200.0.0/24"

        # Apply explicit overrides last
        if overrides:
            params.update(overrides)

        return params

    def _simulate_attack(
        self,
        template: AttackTemplate,
        parameters: Dict[str, Any],
    ) -> AttackExecution:
        """Simulate an attack in the digital twin.

        In production, this would use the KernelDigitalTwin to inject
        actual traffic in the network namespace. For now, we create
        the execution record describing what would happen.
        """
        execution = AttackExecution(
            template_id=template.template_id,
            template_name=template.name,
            category=template.category.value,
            parameters=parameters,
            target_ip=parameters.get("target_ip", parameters.get("victim_ip", "")),
        )

        # If we have a twin, try to run the attack
        if self._twin is not None and hasattr(self._twin, "simulate_attack"):
            try:
                twin_result = self._twin.simulate_attack(
                    template.name, parameters,
                )
                if isinstance(twin_result, dict):
                    execution.success = twin_result.get("success", True)
                    execution.notes = twin_result.get("notes", "")
                else:
                    execution.success = True
            except Exception as e:
                execution.notes = f"Twin simulation error: {e}"
                execution.success = False
        else:
            # No twin — mark as simulated success
            execution.success = True
            execution.notes = "Simulated (no twin connected)"

        return execution

    # ------------------------------------------------------------------
    # Internal: Phase 4 — Impact Assessment
    # ------------------------------------------------------------------

    def _check_detection(self, execution: AttackExecution) -> None:
        """Check if the attack was detected by QSecBit."""
        if self._detection_simulator is not None:
            try:
                detected, layer, latency_ms, severity = self._detection_simulator(
                    execution,
                )
                execution.detected = detected
                execution.detection_layer = layer
                execution.detection_latency_ms = latency_ms
                execution.severity_assigned = severity
            except Exception as e:
                logger.warning("Detection simulator error: %s", e)
                execution.detected = False
                execution.notes += f" | Detection check error: {e}"
        else:
            # Without simulator, use expected detection from template
            template = self._library.get(execution.template_id)
            if template and template.expected_detection.value != "none":
                # Assume detected by default (conservative)
                execution.detected = True
                execution.detection_layer = template.expected_detection.value
                execution.severity_assigned = template.expected_severity
            else:
                # Evasion template — assume not detected
                execution.detected = False

    def _assess_impact(
        self,
        executions: List[AttackExecution],
    ) -> List[VulnerabilityFinding]:
        """Analyze executions to produce vulnerability findings."""
        findings = []

        for execution in executions:
            # Only report if attack succeeded AND evaded detection
            if not execution.evaded_detection:
                continue

            template = self._library.get(execution.template_id)
            finding = VulnerabilityFinding(
                finding_id=self._make_finding_id(execution),
                title=f"Undetected {execution.template_name} attack",
                description=(
                    f"Attack '{execution.template_name}' succeeded against "
                    f"{execution.target_ip} but was not detected by any "
                    f"defense layer."
                ),
                severity=self._classify_severity(template),
                attack_template=execution.template_name,
                mitre_id=template.mitre_id if template else "",
                mitre_technique=template.mitre_technique if template else "",
                target_ip=execution.target_ip,
                detection_gap=(
                    f"Expected detection at {template.expected_detection.value}"
                    if template else "Unknown"
                ),
                recommended_fix=(
                    f"Add signature for {execution.template_name} "
                    f"at {template.expected_detection.value} layer"
                    if template else "Manual review needed"
                ),
                evidence=execution.to_dict(),
            )
            findings.append(finding)

        if findings:
            logger.warning(
                "Shadow pentester found %d detection gaps", len(findings),
            )

        return findings

    def _classify_severity(
        self, template: Optional[AttackTemplate],
    ) -> FindingSeverity:
        """Classify finding severity based on attack template."""
        if template is None:
            return FindingSeverity.MEDIUM

        severity_map = {
            "CRITICAL": FindingSeverity.CRITICAL,
            "HIGH": FindingSeverity.HIGH,
            "MEDIUM": FindingSeverity.MEDIUM,
            "LOW": FindingSeverity.LOW,
        }
        return severity_map.get(template.expected_severity, FindingSeverity.MEDIUM)

    # ------------------------------------------------------------------
    # Internal: Phase 5 — Reporting
    # ------------------------------------------------------------------

    def _report_findings(
        self,
        findings: List[VulnerabilityFinding],
    ) -> None:
        """Report findings to the defense feedback module."""
        if not findings or self._defense_feedback is None:
            return

        for finding in findings:
            try:
                self._defense_feedback.process_finding(finding)
            except Exception as e:
                logger.error(
                    "Failed to report finding %s: %s",
                    finding.finding_id, e,
                )

    # ------------------------------------------------------------------
    # Internal: Helpers
    # ------------------------------------------------------------------

    def _make_cycle_id(self) -> str:
        """Generate a unique cycle ID."""
        data = f"shadow-cycle-{self._cycle_count}-{time.time()}"
        return f"sc-{hashlib.sha256(data.encode()).hexdigest()[:10]}"

    def _make_finding_id(self, execution: AttackExecution) -> str:
        """Generate a unique finding ID."""
        data = f"finding-{execution.template_id}-{execution.target_ip}-{time.time()}"
        return f"sf-{hashlib.sha256(data.encode()).hexdigest()[:10]}"
