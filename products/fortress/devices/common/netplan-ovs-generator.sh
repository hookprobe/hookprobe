#!/bin/bash
#
# netplan-ovs-generator.sh - Generate Netplan config for OVS + VLANs
# Part of HookProbe Fortress - Small Business Security Gateway
#
# Generates netplan YAML for:
#   - OVS bridge (FTS)
#   - VLAN 100 (LAN) with user-configured subnet mask
#   - VLAN 200 (MGMT) with /30 for admin access
#
# Usage:
#   ./netplan-ovs-generator.sh generate [--mask 24] [--lan-ifaces "enp2s0 enp3s0"]
#   ./netplan-ovs-generator.sh apply
#   ./netplan-ovs-generator.sh remove
#
# Version: 5.0.0
# License: AGPL-3.0
#

set -e

# ============================================================
# CONFIGURATION
# ============================================================

# Netplan config file
NETPLAN_FILE="/etc/netplan/60-fortress-ovs.yaml"
NETPLAN_BACKUP="/etc/netplan/60-fortress-ovs.yaml.backup"

# State file for persistence
STATE_DIR="/var/lib/fortress"
STATE_FILE="$STATE_DIR/netplan-config.conf"

# Default values
OVS_BRIDGE="${OVS_BRIDGE:-FTS}"
LAN_MASK="${LAN_MASK:-24}"
VLAN_LAN="${VLAN_LAN:-100}"
VLAN_MGMT="${VLAN_MGMT:-200}"

# Gateway IPs
GATEWAY_LAN="10.200.0.1"
GATEWAY_MGMT="10.200.100.1"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info() { echo -e "${CYAN}[NETPLAN]${NC} $*"; }
log_success() { echo -e "${GREEN}[NETPLAN]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[NETPLAN]${NC} $*"; }
log_error() { echo -e "${RED}[NETPLAN]${NC} $*"; }

# ============================================================
# LOAD STATE
# ============================================================

load_state() {
    if [ -f "$STATE_FILE" ]; then
        # shellcheck source=/dev/null
        source "$STATE_FILE"
        log_info "Loaded saved configuration from $STATE_FILE"
    fi
}

# ============================================================
# SAVE STATE
# ============================================================

save_state() {
    mkdir -p "$STATE_DIR"
    cat > "$STATE_FILE" << EOF
# Fortress Netplan Configuration State
# Generated: $(date)

# Network sizing
LAN_MASK=$LAN_MASK

# VLAN IDs
VLAN_LAN=$VLAN_LAN
VLAN_MGMT=$VLAN_MGMT

# Gateway IPs
GATEWAY_LAN=$GATEWAY_LAN
GATEWAY_MGMT=$GATEWAY_MGMT

# OVS Bridge
OVS_BRIDGE=$OVS_BRIDGE

# LAN interfaces on bridge
LAN_INTERFACES="$LAN_INTERFACES"
EOF
    log_success "Configuration saved to $STATE_FILE"
}

# ============================================================
# GENERATE NETPLAN CONFIG
# ============================================================

generate_netplan() {
    local lan_ifaces="${LAN_INTERFACES:-}"

    log_info "Generating netplan config for OVS bridge..."
    log_info "  Bridge: $OVS_BRIDGE"
    log_info "  LAN VLAN: $VLAN_LAN (10.200.0.1/$LAN_MASK)"
    log_info "  MGMT VLAN: $VLAN_MGMT (10.200.100.1/30)"
    [ -n "$lan_ifaces" ] && log_info "  LAN interfaces: $lan_ifaces"

    # Create netplan directory if needed
    mkdir -p /etc/netplan

    # Backup existing config
    if [ -f "$NETPLAN_FILE" ]; then
        cp "$NETPLAN_FILE" "$NETPLAN_BACKUP"
    fi

    # Start generating YAML content
    local yaml_content=""

    # Add ethernets section if we have LAN interfaces
    if [ -n "$lan_ifaces" ]; then
        yaml_content="  # Physical LAN interfaces (OVS bridge ports)
  ethernets:"
        for iface in $lan_ifaces; do
            # Verify interface exists before adding to config
            if [ -d "/sys/class/net/$iface" ]; then
                yaml_content="$yaml_content
    $iface: {}"
            else
                log_warn "Interface $iface does not exist - skipping"
            fi
        done
        yaml_content="$yaml_content
"
    fi

    # Build bridge config with or without interfaces
    local bridge_config=""
    if [ -n "$lan_ifaces" ]; then
        local valid_ifaces=""
        for iface in $lan_ifaces; do
            if [ -d "/sys/class/net/$iface" ]; then
                valid_ifaces="$valid_ifaces
        - $iface"
            fi
        done
        if [ -n "$valid_ifaces" ]; then
            bridge_config="      interfaces:$valid_ifaces"
        fi
    fi

    # Generate netplan YAML with proper formatting
    # NOTE: We do NOT create VLAN interfaces here. Netplan's vlans: section
    # creates Linux VLAN sub-interfaces (8021q), which don't work correctly
    # with OVS bridges. Instead, ovs-post-setup.sh creates the VLANs as
    # OVS internal ports with proper VLAN tagging.
    cat > "$NETPLAN_FILE" << EOF
# Fortress OVS Network Configuration
# Generated by netplan-ovs-generator.sh
# $(date)
#
# DO NOT EDIT - Managed by Fortress installer
# To modify: edit /var/lib/fortress/netplan-config.conf and run:
#   /opt/hookprobe/fortress/devices/common/netplan-ovs-generator.sh generate
#   netplan apply
#
# IMPORTANT: VLAN interfaces (vlan100, vlan200) are NOT created by netplan.
# They are created by ovs-post-setup.sh as OVS internal ports, which is the
# correct approach for OVS bridges. Netplan's vlans: section creates Linux
# 8021q VLAN interfaces that don't integrate properly with OVS switching.

network:
  version: 2
  renderer: networkd

$yaml_content
  # OVS Bridge - all LAN traffic flows through here
  # NOTE: No IPs on bridge - VLANs are created by ovs-post-setup.sh
  bridges:
    $OVS_BRIDGE:
      openvswitch: {}
$bridge_config
      parameters:
        stp: false
        forward-delay: 0
EOF

    # Set proper permissions (netplan requires 600 for security)
    chmod 600 "$NETPLAN_FILE"

    log_success "Netplan config written to $NETPLAN_FILE"

    # Save state
    save_state
}

# ============================================================
# APPLY NETPLAN
# ============================================================

apply_netplan() {
    log_info "Applying netplan configuration..."

    # Validate first
    if ! netplan generate 2>&1; then
        log_error "Netplan validation failed!"
        if [ -f "$NETPLAN_BACKUP" ]; then
            log_warn "Restoring backup..."
            mv "$NETPLAN_BACKUP" "$NETPLAN_FILE"
        fi
        return 1
    fi

    # Apply with timeout for safety
    if netplan apply 2>&1; then
        log_success "Netplan applied successfully"

        # ============================================================
        # CRITICAL: Wait for OVS bridge to be UP before proceeding
        # ============================================================
        # The bridge must be UP before VLAN interfaces can work properly.
        # Netplan creates the bridge but it may take a moment to initialize.

        log_info "Waiting for OVS bridge $OVS_BRIDGE to come UP..."
        local bridge_wait=0
        local bridge_up=false
        while [ $bridge_wait -lt 30 ]; do
            # Check if bridge exists in OVS
            if ovs-vsctl br-exists "$OVS_BRIDGE" 2>/dev/null; then
                # Bring bridge UP explicitly (in case netplan didn't)
                ip link set "$OVS_BRIDGE" up 2>/dev/null || true

                # Check if it's actually UP
                if ip link show "$OVS_BRIDGE" 2>/dev/null | grep -q "state UP\|state UNKNOWN"; then
                    bridge_up=true
                    log_success "OVS bridge $OVS_BRIDGE is UP"
                    break
                fi
            fi
            sleep 0.5
            bridge_wait=$((bridge_wait + 1))
        done

        if [ "$bridge_up" != "true" ]; then
            log_warn "OVS bridge $OVS_BRIDGE may not be fully UP (continuing anyway)"
            # Try to bring it up one more time
            ip link set "$OVS_BRIDGE" up 2>/dev/null || true
        fi

        # NOTE: VLAN interfaces are NOT created by netplan anymore.
        # They are created by ovs-post-setup.sh as OVS internal ports.
        # This is the correct approach for OVS bridges.
        log_info "VLAN interfaces will be created by ovs-post-setup.sh"
        log_info "  vlan${VLAN_LAN}: ${GATEWAY_LAN}/${LAN_MASK} (LAN)"
        log_info "  vlan${VLAN_MGMT}: ${GATEWAY_MGMT}/30 (MGMT)"

        return 0
    else
        log_error "Netplan apply failed!"
        return 1
    fi
}

# ============================================================
# REMOVE NETPLAN CONFIG
# ============================================================

remove_netplan() {
    log_info "Removing Fortress netplan configuration..."

    if [ -f "$NETPLAN_FILE" ]; then
        rm -f "$NETPLAN_FILE"
        log_info "Removed $NETPLAN_FILE"
    fi

    if [ -f "$NETPLAN_BACKUP" ]; then
        rm -f "$NETPLAN_BACKUP"
    fi

    # Apply to remove interfaces
    netplan apply 2>/dev/null || true

    log_success "Netplan configuration removed"
}

# ============================================================
# STATUS
# ============================================================

show_status() {
    echo -e "\n${CYAN}=== Netplan OVS Status ===${NC}\n"

    echo -e "${CYAN}Config file:${NC}"
    if [ -f "$NETPLAN_FILE" ]; then
        echo "  $NETPLAN_FILE (exists)"
        cat "$NETPLAN_FILE"
    else
        echo "  $NETPLAN_FILE (not found)"
    fi

    echo -e "\n${CYAN}OVS Bridge:${NC}"
    ovs-vsctl show 2>/dev/null || echo "  OVS not available"

    echo -e "\n${CYAN}VLAN Interfaces:${NC}"
    ip -br addr show | grep -E "vlan[0-9]+" || echo "  (none)"

    echo -e "\n${CYAN}Saved State:${NC}"
    if [ -f "$STATE_FILE" ]; then
        cat "$STATE_FILE"
    else
        echo "  (no saved state)"
    fi
}

# ============================================================
# MAIN
# ============================================================

usage() {
    echo "Usage: $0 {generate|apply|remove|status} [options]"
    echo ""
    echo "Commands:"
    echo "  generate    Generate netplan YAML for OVS + VLANs"
    echo "  apply       Apply netplan configuration"
    echo "  remove      Remove Fortress netplan configuration"
    echo "  status      Show current status"
    echo ""
    echo "Options for 'generate':"
    echo "  --mask N           LAN subnet mask (22-29, default: 24)"
    echo "  --lan-ifaces LIST  Space-separated LAN interface list"
    echo "  --bridge NAME      OVS bridge name (default: FTS)"
    echo ""
    echo "Examples:"
    echo "  $0 generate --mask 23 --lan-ifaces 'enp2s0 enp3s0'"
    echo "  $0 apply"
}

main() {
    local action="${1:-}"
    shift || true

    # Load saved state first
    load_state

    # Parse options
    while [ $# -gt 0 ]; do
        case "$1" in
            --mask)
                LAN_MASK="$2"
                shift 2
                ;;
            --lan-ifaces)
                LAN_INTERFACES="$2"
                shift 2
                ;;
            --bridge)
                OVS_BRIDGE="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    case "$action" in
        generate)
            generate_netplan
            ;;
        apply)
            apply_netplan
            ;;
        remove)
            remove_netplan
            ;;
        status)
            show_status
            ;;
        *)
            usage
            exit 1
            ;;
    esac
}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
