#!/bin/bash
#
# traffic-flow-setup.sh - Complete Traffic Flow Configuration for Fortress
# Part of HookProbe Fortress - Small Business Security Gateway
#
# This script configures the complete traffic flow including:
#   - NAT for container networks
#   - PBR integration for all traffic (host + container)
#   - LAN client internet access
#   - Inter-container isolation
#
# Usage:
#   ./traffic-flow-setup.sh setup    # Configure all traffic rules
#   ./traffic-flow-setup.sh validate # Test connectivity
#   ./traffic-flow-setup.sh status   # Show current configuration
#   ./traffic-flow-setup.sh cleanup  # Remove all rules
#
# Version: 1.0.0
# License: AGPL-3.0

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Configuration
CONFIG_FILE="/etc/hookprobe/wan-failover.conf"
NFTABLES_FILE="/etc/nftables.d/fts-traffic.nft"

# Network ranges
CONTAINER_DATA="172.20.200.0/24"
CONTAINER_SERVICES="172.20.201.0/24"
CONTAINER_ML="172.20.202.0/24"
CONTAINER_MGMT="172.20.203.0/24"
LAN_NETWORK="${LAN_NETWORK:-10.200.0.0/23}"

# PBR marks (must match wan-failover-pbr.sh)
FWMARK_PRIMARY=0x100
FWMARK_BACKUP=0x200
FWMARK_MASK=0xf00

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info()  { echo -e "${GREEN}[TRAFFIC]${NC} $1"; }
log_warn()  { echo -e "${YELLOW}[TRAFFIC]${NC} $1"; }
log_error() { echo -e "${RED}[TRAFFIC]${NC} $1" >&2; }
log_section() { echo -e "\n${CYAN}═══ $1 ═══${NC}"; }

# ============================================================
# Load Configuration
# ============================================================

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        . "$CONFIG_FILE"
    fi

    # Defaults
    PRIMARY_IFACE="${PRIMARY_IFACE:-eth0}"
    BACKUP_IFACE="${BACKUP_IFACE:-wwan0}"
}

# ============================================================
# NAT Configuration
# ============================================================

setup_nat() {
    log_section "Configuring NAT"

    # Get WAN interfaces
    local wan_ifaces=""
    if [ -n "$PRIMARY_IFACE" ] && ip link show "$PRIMARY_IFACE" &>/dev/null; then
        wan_ifaces="$PRIMARY_IFACE"
    fi
    if [ -n "$BACKUP_IFACE" ] && ip link show "$BACKUP_IFACE" &>/dev/null; then
        wan_ifaces="$wan_ifaces $BACKUP_IFACE"
    fi

    if [ -z "$wan_ifaces" ]; then
        log_warn "No WAN interfaces found"
        wan_ifaces="eth0"
    fi

    log_info "WAN interfaces: $wan_ifaces"

    # Create nftables NAT rules
    mkdir -p /etc/nftables.d

    cat > "$NFTABLES_FILE" << 'NFTEOF'
#!/usr/sbin/nft -f
#
# HookProbe Fortress - Traffic Flow Rules
# Auto-generated by traffic-flow-setup.sh
#

# Clean up existing fortress tables
table inet fts_nat
delete table inet fts_nat

table inet fts_nat {
    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;

        # DNS redirect: LAN clients → dnsmasq (which forwards to dnsXai)
        # This ensures DNS goes through our ML protection
        # ip saddr 10.200.0.0/23 udp dport 53 redirect to :53
    }

    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;

        # SNAT for container replies to LAN clients
        # Containers on 172.20.200.0/24 replying to LAN clients (10.200.x.x)
        # must use the MGMT gateway IP so clients see responses from
        # the same IP they connected to (10.200.100.1 for dashboard)
        ip saddr 172.20.200.0/24 ip daddr 10.200.0.0/8 snat to 10.200.100.1

NFTEOF

    # Add masquerade rules for each WAN interface
    for iface in $wan_ifaces; do
        cat >> "$NFTABLES_FILE" << EOF
        # NAT for container services tier → $iface
        ip saddr $CONTAINER_SERVICES oifname "$iface" masquerade

        # NAT for LAN clients → $iface
        ip saddr $LAN_NETWORK oifname "$iface" masquerade

EOF
    done

    cat >> "$NFTABLES_FILE" << 'NFTEOF'
    }
}

# PBR marking for container traffic (FORWARD chain)
# Ensures container-originated traffic uses correct WAN based on failover state
table inet fts_forward_mark
delete table inet fts_forward_mark

table inet fts_forward_mark {
    chain forward {
        type filter hook forward priority mangle; policy accept;

        # Skip if already marked (by OUTPUT chain or conntrack)
        meta mark & 0xf00 != 0 return

        # Mark container-originated traffic for PBR
        # The actual mark value is managed by wan-failover-pbr.sh
        # This chain is updated dynamically when failover state changes
    }
}
NFTEOF

    # Apply nftables rules
    log_info "Applying nftables rules..."
    nft -f "$NFTABLES_FILE" || {
        log_error "Failed to apply nftables rules"
        return 1
    }

    log_info "NAT configured for: $wan_ifaces"
}

# ============================================================
# PBR Integration for Containers
# ============================================================

setup_pbr_forward() {
    log_section "Configuring PBR for Container Traffic"

    # Check if PBR is active
    if ! ip rule show | grep -q "fwmark.*table 100"; then
        log_warn "PBR not active. Run: wan-failover-pbr.sh setup"
        return 0
    fi

    # Get current active WAN from failover state
    local active_wan="primary"
    local mark=$FWMARK_PRIMARY

    if [ -f "/run/fortress/wan-failover.state" ]; then
        # shellcheck source=/dev/null
        . /run/fortress/wan-failover.state
        active_wan="${ACTIVE_WAN:-primary}"
    fi

    case "$active_wan" in
        primary) mark=$FWMARK_PRIMARY ;;
        backup)  mark=$FWMARK_BACKUP ;;
    esac

    log_info "Active WAN: $active_wan (mark $mark)"

    # Update forward chain to mark container traffic
    nft -f - << EOF
flush chain inet fts_forward_mark forward

table inet fts_forward_mark {
    chain forward {
        type filter hook forward priority mangle; policy accept;

        # Skip if already marked
        meta mark & 0xf00 != 0 return

        # Skip local traffic
        ip daddr 10.0.0.0/8 return
        ip daddr 172.16.0.0/12 return
        ip daddr 192.168.0.0/16 return

        # Mark container traffic from services tier (internet-allowed)
        ip saddr $CONTAINER_SERVICES meta mark set $mark

        # Mark LAN client traffic
        ip saddr $LAN_NETWORK meta mark set $mark
    }
}
EOF

    log_info "Container PBR marking configured"
}

# ============================================================
# IP Forwarding
# ============================================================

setup_forwarding() {
    log_section "Enabling IP Forwarding"

    # Enable IP forwarding
    echo 1 > /proc/sys/net/ipv4/ip_forward

    # Make persistent
    if ! grep -q "^net.ipv4.ip_forward" /etc/sysctl.conf 2>/dev/null; then
        echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf
    fi

    log_info "IP forwarding enabled"
}

# ============================================================
# dnsmasq Configuration
# ============================================================

setup_dns_forwarding() {
    log_section "Configuring DNS Forwarding"

    local dnsmasq_conf="/etc/dnsmasq.d/fts-dns-forward.conf"
    local main_config="/etc/dnsmasq.d/fts-vlan.conf"

    # Check if fts-vlan.conf exists AND already has server= lines configured
    # If so, skip creating fts-dns-forward.conf entirely to avoid duplicate entries
    if [ -f "$main_config" ] && grep -q "^server=" "$main_config" 2>/dev/null; then
        log_info "DNS forwarding already configured in fts-vlan.conf"
        # Remove any stale fts-dns-forward.conf to avoid duplicates
        if [ -f "$dnsmasq_conf" ]; then
            rm -f "$dnsmasq_conf"
            log_info "Removed redundant fts-dns-forward.conf"
        fi
        # Reload dnsmasq if running to apply any changes
        if systemctl is-active dnsmasq &>/dev/null; then
            systemctl reload dnsmasq 2>/dev/null || true
        fi
        return 0
    fi

    # No main config with DNS - create fts-dns-forward.conf
    # Check if dnsXai container is running
    if podman ps --format "{{.Names}}" 2>/dev/null | grep -q "fts-dnsxai"; then
        log_info "dnsXai container detected, configuring DNS forwarding"

        cat > "$dnsmasq_conf" << 'EOF'
# HookProbe Fortress - DNS Forwarding to dnsXai
# Forward DNS queries to ML-powered DNS protection

# Primary: dnsXai container
server=127.0.0.1#5353

# Fallback: Public DNS if dnsXai is unavailable
server=1.1.1.1
server=8.8.8.8

# Don't use /etc/resolv.conf
no-resolv

# Cache size
cache-size=1000
EOF
    else
        log_warn "dnsXai container not running, using fallback DNS"
        cat > "$dnsmasq_conf" << 'EOF'
# HookProbe Fortress - DNS Forwarding (fallback)
# dnsXai not available, using public DNS

server=1.1.1.1
server=8.8.8.8
no-resolv
cache-size=1000
EOF
    fi

    # Reload dnsmasq if running
    if systemctl is-active dnsmasq &>/dev/null; then
        systemctl reload dnsmasq
        log_info "dnsmasq reloaded with DNS forwarding config"
    fi
}

# ============================================================
# Validation
# ============================================================

validate_connectivity() {
    log_section "Validating Traffic Flow"

    local errors=0

    # 1. Check IP forwarding
    log_info "Checking IP forwarding..."
    if [ "$(cat /proc/sys/net/ipv4/ip_forward)" = "1" ]; then
        echo "  ✅ IP forwarding enabled"
    else
        echo "  ❌ IP forwarding disabled"
        errors=$((errors + 1))
    fi

    # 2. Check NAT rules
    log_info "Checking NAT rules..."
    if nft list table inet fts_nat 2>/dev/null | grep -q "masquerade"; then
        echo "  ✅ NAT masquerade rules present"
    else
        echo "  ❌ NAT masquerade rules missing"
        errors=$((errors + 1))
    fi

    # 3. Check PBR
    log_info "Checking PBR..."
    if ip rule show | grep -q "fwmark.*table 100"; then
        echo "  ✅ PBR rules present"
    else
        echo "  ⚠️  PBR not configured (single WAN?)"
    fi

    # 4. Check container networks
    log_info "Checking container networks..."
    for net in fts-data fts-services fts-mgmt; do
        if podman network exists "$net" 2>/dev/null; then
            echo "  ✅ Network $net exists"
        else
            echo "  ❌ Network $net missing"
            errors=$((errors + 1))
        fi
    done

    # 5. Check container connectivity
    log_info "Checking container connectivity..."

    # web → postgres
    if podman exec fts-web ping -c1 -W2 172.20.200.10 &>/dev/null; then
        echo "  ✅ web → postgres: OK"
    else
        echo "  ❌ web → postgres: FAILED"
        errors=$((errors + 1))
    fi

    # dnsxai → internet
    if podman exec fts-dnsxai ping -c1 -W2 1.1.1.1 &>/dev/null; then
        echo "  ✅ dnsxai → internet: OK"
    else
        echo "  ❌ dnsxai → internet: FAILED (check NAT)"
        errors=$((errors + 1))
    fi

    # grafana → postgres (if running)
    if podman ps --format "{{.Names}}" 2>/dev/null | grep -q "fts-grafana"; then
        if podman exec fts-grafana ping -c1 -W2 172.20.200.10 &>/dev/null; then
            echo "  ✅ grafana → postgres: OK"
        else
            echo "  ❌ grafana → postgres: FAILED"
            errors=$((errors + 1))
        fi
    fi

    # 6. Check DNS
    log_info "Checking DNS resolution..."
    if dig +short +timeout=2 hookprobe.com @127.0.0.1 | grep -q "[0-9]"; then
        echo "  ✅ DNS resolution: OK"
    else
        echo "  ⚠️  DNS resolution: FAILED (may be expected)"
    fi

    echo ""
    if [ $errors -eq 0 ]; then
        log_info "✅ All validations passed"
    else
        log_error "❌ $errors validation(s) failed"
    fi

    return $errors
}

# ============================================================
# Status
# ============================================================

show_status() {
    log_section "Traffic Flow Status"

    echo ""
    echo "NAT Rules:"
    echo "─────────────────────────────────────────────"
    nft list table inet fts_nat 2>/dev/null | grep -E "(masquerade|redirect)" | sed 's/^/  /'
    echo ""

    echo "PBR Forward Marks:"
    echo "─────────────────────────────────────────────"
    nft list table inet fts_forward_mark 2>/dev/null | grep -E "mark set" | sed 's/^/  /' || echo "  (not configured)"
    echo ""

    echo "IP Forwarding:"
    echo "─────────────────────────────────────────────"
    echo "  net.ipv4.ip_forward = $(cat /proc/sys/net/ipv4/ip_forward)"
    echo ""

    echo "Container Networks:"
    echo "─────────────────────────────────────────────"
    podman network ls 2>/dev/null | grep fts | sed 's/^/  /'
    echo ""

    echo "WAN Failover Status:"
    echo "─────────────────────────────────────────────"
    if [ -x "/opt/hookprobe/fortress/devices/common/wan-failover-pbr.sh" ]; then
        /opt/hookprobe/fortress/devices/common/wan-failover-pbr.sh status 2>/dev/null | head -20
    else
        echo "  (WAN failover not installed)"
    fi
}

# ============================================================
# Cleanup
# ============================================================

cleanup() {
    log_section "Cleaning Up Traffic Rules"

    # Remove nftables tables
    nft delete table inet fts_nat 2>/dev/null || true
    nft delete table inet fts_forward_mark 2>/dev/null || true

    # Remove config file
    rm -f "$NFTABLES_FILE"

    # Remove dnsmasq config
    rm -f /etc/dnsmasq.d/fts-dns-forward.conf
    systemctl reload dnsmasq 2>/dev/null || true

    log_info "Traffic rules cleaned up"
}

# ============================================================
# Main
# ============================================================

cmd_setup() {
    load_config
    setup_forwarding
    setup_nat
    setup_pbr_forward
    setup_dns_forwarding
    log_info "Traffic flow setup complete"
}

case "${1:-}" in
    setup)
        cmd_setup
        ;;
    validate)
        validate_connectivity
        ;;
    status)
        show_status
        ;;
    cleanup)
        cleanup
        ;;
    *)
        echo "Usage: $0 {setup|validate|status|cleanup}"
        echo ""
        echo "Commands:"
        echo "  setup    - Configure NAT, PBR, and DNS forwarding"
        echo "  validate - Test connectivity"
        echo "  status   - Show current configuration"
        echo "  cleanup  - Remove all traffic rules"
        exit 1
        ;;
esac
